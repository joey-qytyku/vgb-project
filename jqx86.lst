     1                                  ;Copyright (c) 2022 Joey Qytyku
     2                                  
     3                                  ;Permission is hereby granted, free of charge, to any person obtaining a copy
     4                                  ;of this software and associated documentation files (the "Software"), to deal
     5                                  ;in the Software without restriction, including without limitation the rights
     6                                  ;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     7                                  ;copies of the Software, and to permit persons to whom the Software is
     8                                  ;furnished to do so, subject to the following conditions:
     9                                  
    10                                  ;The above copyright notice and this permission notice shall be included in all
    11                                  ;copies or substantial portions of the Software.
    12                                  
    13                                  ;THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    14                                  ;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    15                                  ;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    16                                  ;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    17                                  ;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    18                                  ;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    19                                  ;SOFTWARE.
    20                                  
    21                                          %define SYS_EXIT        1
    22                                          %define SYS_READ        3
    23                                          %define SYS_OPEN        5
    24                                          %define SYS_STAT        0x12
    25                                          %define O_CREAT         00000100
    26                                          %define O_TRUNC         00001000
    27                                          %define O_RDONLY        00000000
    28                                          %define STAT_SIZE       48
    29                                          %define MEM_SIZE        65536
    30                                  
    31                                          %define X86_CF          1<<0
    32                                          %define X86_ZF          40h
    33                                  
    34                                          ;Single byte opcodes using ModRM/Reg to encode RegOps
    35                                          %define X86.MOV_R2R    89h
    36                                          %define X86.MOV_M2R    8Bh
    37                                  
    38                                  ;-------------------------------------------------------------------------------
    39                                  ; Equates
    40                                  ;-------------------------------------------------------------------------------
    41                                          JQ.HALT EQU     0
    42                                  ;-------------------------------------------------------------------------------
    43                                  
    44                                  ;-------------------------------------------------------------------------------
    45                                  ; Linking information
    46                                  ;-------------------------------------------------------------------------------
    47                                  
    48                                          global  main
    49                                          extern  malloc, free, printf, puts
    50                                  
    51                                  ;-------------------------------------------------------------------------------
    52                                          section .bss
    53                                  
    54 00000000 <res 20h>               alRegBuffer     RESD    8
    55 00000020 ????????                lProgramCounter RESD    1
    56 00000024 ????????                pMemory         RESD    1
    57 00000028 ????????                BytesLeftBlock  RESD    1
    58                                  
    59 0000002C ??                      bFlags          RESB    1
    60 0000002D <res 90h>               abStatBuffer    RESB    144
    61 000000BD <res 1000h>             ExecBuffer      RESB    4096
    62                                  
    63                                          section .data
    64                                  
    65 00000000 4F703D257820202020-     strDebugMsg     DB      "Op=%x    Rd=%x    Rs1=%x    Rs2=%x    Imm=%x",10,0
    65 00000009 52643D257820202020-
    65 00000012 5273313D2578202020-
    65 0000001B 205273323D25782020-
    65 00000024 2020496D6D3D25780A-
    65 0000002D 00                 
    66 0000002E 4A517838360A436F70-     strCopyrightMsg DB      "JQx86",10,"Copyright (c) 2022 Joey Qytyku",0
    66 00000037 797269676874202863-
    66 00000040 292032303232204A6F-
    66 00000049 657920517974796B75-
    66 00000052 00                 
    67 00000053 4572726F7220737461-     strStartuperror DB      "Error starting virtual machine",0
    67 0000005C 7274696E6720766972-
    67 00000065 7475616C206D616368-
    67 0000006E 696E6500           
    68                                  
    69                                  ;Array of call pointers
    70                                  afCallTable:
    71 00000072 [2C000000]                      DD      Conv.LDI
    72                                  
    73                                          section .text
    74                                  
    75                                  ;###############################################################################
    76                                  ;############################## Helper functions ###############################
    77                                  ;###############################################################################
    78                                  
    79                                  
    80                                  Helper.MoveRegToReg:
    81 00000000 E810000000                      call    EncodeR2rModRM
    82                                  Helper.CmpRegs:
    83                                  
    84                                  ;
    85                                  ;All arithmetic and bitwise instructions are register-to-register
    86                                  ;so the ModRM/Reg direction is not that important.
    87                                  ;
    88                                  Helper.Addition:
    89                                  Helper.Subtraction:
    90                                  Helper.Multiplication:
    91                                  Helper.Division:
    92                                  
    93                                  ;No need to decode ModRM, reg specified in opcode
    94                                  ;Uses EBP as the register and EDX as the immediate
    95                                  ;
    96                                  ;The MakeIMM procedure must be used to generate the immediate value
    97                                  ;
    98                                  Helper.MoveImmToReg:
    99 00000005 31C0                            xor     eax,eax
   100 00000007 B0B8                            mov     al,10111000b
   101 00000009 09E8                            or      eax,ebp
   102 0000000B AA                              stosb
   103 0000000C 89D0                            mov     eax,edx
   104 0000000E C1E003                          shl     eax,3
   105 00000011 09E8                            or      eax,ebp
   106 00000013 AB                              stosd
   107 00000014 C3                              ret
   108                                  
   109                                  ;-------------------------------------------------------------------------------
   110                                  ; Procedure EncodeR2rModRM:
   111                                  ;       Generate a ModRM byte to represent a register-to-register operation
   112                                  ;
   113                                  ;       A reg-to-reg ModRM byte looks like this
   114                                  ;       11rrrRRR, where 11 indicates register addressing
   115                                  ;       and rrr+RRR are the two register operands.
   116                                  ;
   117                                  ; INPUTS:       EBP=Reg1 (source operand)   EDX=Reg2 (destination operand)
   118                                  ; OUTPUTS:      EAX=Reg-to-reg ModRM byte produced
   119                                  ; CLOBBERS:     EAX, the output code buffer
   120                                  EncodeR2rModRM:
   121 00000015 89D0                            mov     eax,edx
   122 00000017 C1E003                          shl     eax,3
   123 0000001A 09E8                            or      eax,ebp
   124 0000001C 0D00000011                      or      eax,11000000h
   125 00000021 AA                              stosb
   126 00000022 C3                              ret
   127                                  
   128                                  ;-------------------------------------------------------------------------------
   129                                  ; Procedure: MakeIMM
   130                                  ; In JQ-RISC, the immediate value is made of R1 and R2. The rest of the
   131                                  ; bits are unused for decoding simplicity. This takes the R1 and R2 fields
   132                                  ; and bitwise them together in EAX
   133                                  ;
   134                                  MakeIMM:
   135 00000023 89D0                            mov     eax,edx
   136 00000025 C1E003                          shl     eax,3
   137 00000028 09E8                            or      eax,ebp
   138 0000002A C3                              ret
   139                                  
   140                                  EncodeSIB:
   141 0000002B C3                              ret
   142                                  
   143                                  ;###############################################################################
   144                                  ;########################### End of Helper functions ###########################
   145                                  ;###############################################################################
   146                                  
   147                                  
   148                                  ;###############################################################################
   149                                  ;######################## Start of Conversion functions ########################
   150                                  ;###############################################################################
   151                                  
   152                                  
   153                                  ;
   154                                  ; if destination reg is zero register, generate a NOP
   155                                  ; This is immediate, so there is no source register
   156                                  ;
   157                                  Conv.LDI:
   158 0000002C 83FA06                          cmp     edx,6
   159 0000002F 7507                            jne     .RegularMove    ;If not zero, encode the operation
   160                                                                  ;Otherwise encode a NOP
   161 00000031 B890000000                      mov     eax,90h
   162 00000036 AA                              stosb
   163 00000037 C3                              ret
   164                                  
   165                                  .RegularMove:   ;We are moving an immediate value to a scratch register
   166 00000038 E8E6FFFFFF                      call    MakeIMM                 ;Return value in EAX
   167 0000003D 89C2                            mov     edx,eax
   168 0000003F E8C1FFFFFF                      call    Helper.MoveImmToReg
   169 00000044 C3                              ret
   170                                  
   171                                  Conv.LDM:
   172                                          ;Memory access requires generating an MOV with the immediate value
   173                                          ;32-bit for optimizations
   174                                          ;The base register is also the register where it is written for loads
   175                                  
   176                                          ;Last reg operand is the index (ECX)
   177 00000045 A1[24000000]                    mov     eax,[pMemory]
   178 0000004A 03048D[00000000]                add     eax,[alRegBuffer+ecx*4]
   179 00000051 8B00                            mov     eax,[eax]
   180                                          ;Now the memory has been "accessed"
   181                                          ;Time to write it to the register
   182 00000053 E8ADFFFFFF                      call    Helper.MoveImmToReg     ; How does this work?
   183                                  
   184                                  Conv.STM:
   185                                  
   186                                  Conv.AD:
   187 00000058 B801000000                      mov     eax,1   ;80x86 Add reg,modrm
   188 0000005D AA                              stosb
   189                                          ;Generate a reg+modrm byte
   190                                  
   191                                  Conv.SB:
   192                                  
   193                                  
   194                                  Conv.SHF:
   195                                          ;but variable shifts are slow, on some processors
   196                                          ;the speed is dependent on the shift count
   197                                          ;and it requires clobbering CL
   198                                          ;This means that encoding an immediate l/r shift is
   199                                          ;the only option.
   200                                  
   201                                  
   202                                  Conv.SHI:
   203                                  
   204                                  Conv.SWI:
   205 0000005E B8CD800000                      mov     eax,80CDh
   206 00000063 66AB                            stosw
   207 00000065 C3                              ret
   208                                  
   209                                  Conv.B:
   210                                  
   211                                  Conv.HALT:
   212                                          ;Encode a jump to routine Termination
   213 00000066 BE[6E000000]                    mov     esi,.code
   214 0000006B A5                              movsd
   215 0000006C A5                              movsd
   216 0000006D C3                              ret
   217                                  .code:
   218 0000006E B8[7E010000]                    mov     eax,Termination ; B8 xx xx xx xx
   219 00000073 FFE0                            jmp     eax             ; FF E0
   220 00000075 90                              nop
   221                                  
   222                                  ;###############################################################################
   223                                  ;######################## End of Conversion functions ##########################
   224                                  ;###############################################################################
   225                                  
   226                                  ;###############################################################################
   227                                  ;###################### Start of Main Execution Procedure ######################
   228                                  ;###############################################################################
   229 00000076 90<rep Ah>                      align   64
   230                                  ExecuteVM:
   231                                          ;I tried to use SSE/MMX to no avail. The only way I can think of is
   232                                          ;to decode instructions one by one
   233                                  
   234 00000080 C705[28000000]0010-             mov     dword [BytesLeftBlock],4096
   234 00000088 0000               
   235                                  
   236                                  .Emit:
   237                                  
   238 0000008A A1[20000000]                    mov     eax,[lProgramCounter]
   239 0000008F 0FB718                          movzx   ebx, word [eax]
   240 00000092 89D9                            mov     ecx,ebx
   241 00000094 89DA                            mov     edx,ebx
   242 00000096 89DD                            mov     ebp,ebx
   243                                  
   244 00000098 BE07000000                      mov     esi,7
   245                                          ;EBX=Opcode
   246 0000009D C1EB03                          shr     ebx,3
   247 000000A0 21F3                            and     ebx,esi
   248 000000A2 83FB00                          cmp     ebx,JQ.HALT
   249 000000A5 7505                            jnz      .NotHalt
   250 000000A7 E9D2000000                      jmp     Termination
   251                                  
   252                                  .NotHalt:
   253                                  
   254                                          ;ECX=REG1
   255 000000AC C1E908                          shr     ecx,8
   256 000000AF 21F1                            and     ecx,esi
   257                                          ;EDX=REG2
   258 000000B1 C1EA03                          shr     edx,3
   259 000000B4 21F2                            and     edx,esi
   260                                          ;EBP=REG3
   261 000000B6 21F5                            and     ebp,esi
   262                                  
   263 000000B8 60                              pusha
   264 000000B9 55                              push    ebp
   265 000000BA 52                              push    edx
   266 000000BB 51                              push    ecx
   267 000000BC 53                              push    ebx
   268 000000BD 68[00000000]                    push    strDebugMsg
   269 000000C2 E8(00000000)                    call    printf
   270 000000C7 61                              popa
   271                                  
   272                                          ;x86 instructions are no longer than 15 bytes
   273                                          ;There has to be space for an extra RET instruction to get back
   274                                          ;to ExecuteVM, so the interpreter must execute the block
   275                                          ;if there is no more space left for instructions and the RET
   276                                  
   277 000000C8 803D[28000000]10                cmp     byte [BytesLeftBlock],16
   278 000000CF 7305                            jae     .ClearToEmit
   279 000000D1 E84C000000                      call    RunBlock
   280                                  .ClearToEmit:
   281                                          ;Emit an instruction
   282 000000D6 8B3D[20000000]                  mov     edi,[lProgramCounter]
   283 000000DC FF149D[72000000]                call    [ebx*4+afCallTable]
   284 000000E3 893D[20000000]                  mov     [lProgramCounter],edi
   285                                  
   286                                          ;Was this a branch?
   287 000000E9 83F8FF                          cmp     eax,-1  ; Branch if carry
   288 000000EC 7417                            je      .BC
   289 000000EE 83F8FE                          cmp     eax,-2  ; Branch if zero
   290 000000F1 7407                            je      .BZ
   291 000000F3 83F8FD                          cmp     eax,-3  ; Branch unconditionally
   292 000000F6 7416                            je      .doBranch
   293                                  
   294 000000F8 EB14                            jmp     .dontDoBranch   ; Do not do branch because this is not a Bx op
   295                                  .BZ:
   296 000000FA F605[2C000000]40                test    byte[bFlags],X86_ZF
   297 00000101 750B                            jnz     .doBranch
   298 00000103 EB09                            jmp     .dontDoBranch
   299                                  .BC:
   300 00000105 F605[2C000000]01                test    byte[bFlags],X86_CF
   301 0000010C 7500                            jnz     .doBranch
   302                                  .doBranch:
   303                                          ;Set the vPC to the branch target so that it runs there
   304                                  .dontDoBranch:
   305                                          ;Its not a branch or was and not taken
   306                                  
   307                                          ;BytesLeftBlock = EDI - (ExecBuffer+4096)
   308 0000010E 81EF[BD100000]                  sub     edi,ExecBuffer+4096
   309                                                  ;BytesLeftBlock = EDI 
   310 00000114 8B3D[20000000]                  mov     edi,[lProgramCounter]
   311 0000011A 83EF00                          sub     edi,ExecBuffer+4096 - (ExecBuffer+4096)
   312                                  
   313                                          ;Conversion functions append bytes to the execution buffer using STOS
   314                                          ;The program counter always points
   315                                          ;to the next byte to insert an instruction (like a normal PC)
   316 0000011D E968FFFFFF                      jmp     .Emit
   317                                  
   318                                  RunBlock:
   319                                          ;When running generated x86 code, all registers, including flags
   320                                          ;are garaunteed to be clobbered. The only thing that matters
   321                                          ;is loading the previous state of the last block so that the
   322                                          ;next one can continue where the previous one left off.
   323                                          ;So the procedure is to get the last state, run the block
   324                                          ;and save the result for later.
   325                                  
   326                                          ;Code is generated as long as there are 16 or more bytes left
   327                                          ;in the block. If there is not. an instruction is not generated
   328                                          ;and .RunBlock takes control
   329                                  
   330 00000122 B8C3000000                      mov     eax,0C3h        ;Put it in
   331 00000127 AA                              stosb                   ;There is space
   332                                  
   333 00000128 8A25[2C000000]                  mov     ah,[bFlags]
   334 0000012E 9F                              lahf
   335                                  
   336                                          ;Fetch the x86 register state
   337 0000012F BB[00000000]                    mov     ebx,alRegBuffer
   338 00000134 8B03                            mov     eax,[ebx]
   339 00000136 8B4B08                          mov     ecx,[ebx+8]
   340 00000139 8B530C                          mov     edx,[ebx+12]
   341 0000013C 8B7310                          mov     esi,[ebx+16]
   342 0000013F 8B7B14                          mov     edi,[ebx+20]
   343 00000142 8B6B18                          mov     ebp,[ebx+24]
   344 00000145 8B5B04                          mov     ebx,[ebx+4]
   345                                  
   346 00000148 E8(BD000000)                    call    ExecBuffer      ;Run the generated code
   347                                  
   348                                          ;Save x86 register state to memory
   349                                          ;TODO: optimize this so no abs addresses
   350 0000014D A3[00000000]                    mov     [alRegBuffer+0],eax
   351 00000152 891D[04000000]                  mov     [alRegBuffer+4],ebx
   352 00000158 890D[08000000]                  mov     [alRegBuffer+8],ecx
   353 0000015E 8915[0C000000]                  mov     [alRegBuffer+12],edx
   354 00000164 8935[10000000]                  mov     [alRegBuffer+16],esi
   355 0000016A 893D[14000000]                  mov     [alRegBuffer+20],edi
   356 00000170 892D[18000000]                  mov     [alRegBuffer+24],ebp
   357 00000176 9E                              sahf
   358 00000177 8825[2C000000]                  mov     byte[bFlags],ah
   359                                  
   360 0000017D C3                              ret     ;Block has finished executing, run a new one
   361                                  
   362                                  
   363                                  ;###############################################################################
   364                                  ;###################### End of Main Execution Procedure ########################
   365                                  ;###############################################################################
   366                                  
   367                                  ;-------------------------------------------------------------------------------
   368                                  ; Procedure: Termination
   369                                  ; Exits the program
   370                                  Termination:
   371 0000017E B801000000                      mov     eax,SYS_EXIT
   372 00000183 31DB                            xor     ebx,ebx
   373 00000185 CD80                            int     80h
   374                                  
   375                                  ;-------------------------------------------------------------------------------
   376                                  ; Procedure: main
   377                                  ; argv[1] is the binary to execute
   378                                  ;-------------------------------------------------------------------------------
   379                                  main:
   380 00000187 FC                              cld     ; Clear for entire program
   381                                  
   382 00000188 68[2E000000]                    push    strCopyrightMsg
   383 0000018D E8(00000000)                    call    puts
   384 00000192 83C404                          add     esp,4
   385                                  
   386 00000195 837C240401                      cmp     dword [esp+4],1 ;Check argument count
   387 0000019A 7262                            jb      .StartError
   388                                  
   389 0000019C 8B5C2408                        mov     ebx,[esp+8]
   390 000001A0 8B5B04                          mov     ebx,[ebx+4]     ; Get argv[1] in EBX
   391                                  
   392                                          ;Open the executable flat binary
   393 000001A3 B805000000                      mov     eax,SYS_OPEN
   394 000001A8 B900000000                      mov     ecx,O_RDONLY
   395 000001AD BAFF010000                      mov     edx,777q
   396 000001B2 CD80                            int     80h
   397                                          ;EAX is the file descriptor, if -1, failed
   398 000001B4 83F8FF                          cmp     eax,-1
   399 000001B7 7445                            je      .StartError
   400                                  
   401 000001B9 50                              push    eax             ;Save the FD
   402 000001BA 6800000100                      push    MEM_SIZE
   403 000001BF E8(00000000)                    call    malloc          ;Allocate the memory
   404 000001C4 83C404                          add     esp,4           ;Clean stack
   405                                  
   406 000001C7 85C0                            test    eax,eax         ; Is result NULL
   407 000001C9 7433                            je      .StartError
   408                                  
   409                                          ;EAX contains pointer to allocated buffer
   410                                          ;On the stack is the FD
   411                                  
   412                                          ;Read the executable data into the buffer
   413 000001CB 89C1                            mov     ecx,eax         ;Buffer address
   414 000001CD 5B                              pop     ebx             ;File descriptor
   415 000001CE B803000000                      mov     eax,SYS_READ    ;Syscall
   416 000001D3 8B15[2D000000]                  mov     edx,[abStatBuffer]
   417 000001D9 CD80                            int     80h
   418                                  
   419                                          ;Close the file, it is no longer needed
   420 000001DB B806000000                      mov     eax,SYS_OPEN+1
   421 000001E0 CD80                            int     80h
   422                                  
   423                                          ;ECX is still return of malloc()
   424                                  
   425                                          ;Buffer contains the code to be executed by JQx86
   426                                          ;PC initialized to the start of the buffer
   427 000001E2 890D[20000000]                  mov     [lProgramCounter],ecx
   428 000001E8 890D[24000000]                  mov     [pMemory],ecx
   429                                  
   430                                          ;Execute the VM
   431 000001EE E88DFEFFFF                      call    ExecuteVM
   432                                  
   433                                          ;Deallocate memory
   434                                  .KillMachine:
   435 000001F3 FF35[24000000]                  push    dword [pMemory]
   436 000001F9 E8(00000000)                    call    free
   437                                  .StartError:
   438                                          ;There is no memory to free
   439 000001FE 68[53000000]                    push    strStartuperror
   440 00000203 E8(00000000)                    call    puts
   441 00000208 B801000000                      mov     eax,SYS_EXIT
   442 0000020D CD80                            int     80h
